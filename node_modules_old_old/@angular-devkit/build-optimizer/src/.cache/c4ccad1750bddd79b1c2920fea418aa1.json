{"remainingRequest":"/Users/dennismenjivar/Documents/Collocations/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/dennismenjivar/Documents/Collocations/node_modules/ngx-chips/ngx-chips.es5.js","dependencies":[{"path":"/Users/dennismenjivar/Documents/Collocations/node_modules/ngx-chips/ngx-chips.es5.js","mtime":1525967492511},{"path":"/Users/dennismenjivar/Documents/Collocations/node_modules/cache-loader/dist/cjs.js","mtime":1531196722320},{"path":"/Users/dennismenjivar/Documents/Collocations/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1531196709571}],"contextDependencies":[],"result":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b)\n            if (b.hasOwnProperty(p))\n                d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { ChangeDetectorRef, Component, ContentChild, ContentChildren, ElementRef, EventEmitter, HostBinding, HostListener, Injectable, Injector, Input, NgModule, Output, Pipe, Renderer2, TemplateRef, ViewChild, ViewChildren, animate, forwardRef, keyframes, state, style, transition, trigger } from '@angular/core';\nimport { COMPOSITION_BUFFER_MODE, FormControl, FormGroup, FormsModule, NG_VALUE_ACCESSOR, ReactiveFormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\nimport { Ng2Dropdown, Ng2DropdownModule } from 'ng2-material-dropdown';\nimport { Observable as Observable$1 } from 'rxjs/Observable';\nimport 'rxjs/add/observable/of';\nimport 'rxjs/add/operator/debounceTime';\nimport 'rxjs/add/operator/filter';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/first';\nimport { animate as animate$1, keyframes as keyframes$1, state as state$1, style as style$1, transition as transition$1, trigger as trigger$1 } from '@angular/animations';\nvar escape = function (s) { return s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'); };\nvar HighlightPipe = /*@__PURE__*/ (function () {\n    function HighlightPipe() {\n    }\n    /**\n     * \\@name transform\n     * @param {?} value {string}\n     * @param {?} arg {string}\n     * @return {?}\n     */\n    HighlightPipe.prototype.transform = function (value, arg) {\n        if (!arg.trim()) {\n            return value;\n        }\n        try {\n            var /** @type {?} */ regex = new RegExp(\"(\" + escape(arg) + \")\", 'i');\n            return value.replace(regex, '<b>$1</b>');\n        }\n        catch (e) {\n            return value;\n        }\n    };\n    return HighlightPipe;\n}());\n/*\n** constants and default values for <tag-input>\n */\n/*\n** constants and default values for <tag-input>\n */ var PLACEHOLDER = '+ Tag';\nvar SECONDARY_PLACEHOLDER = 'Enter a new tag';\nvar KEYDOWN = 'keydown';\nvar KEYUP = 'keyup';\nvar MAX_ITEMS_WARNING = 'The number of items specified was greater than the property max-items.';\nvar ACTIONS_KEYS = {\n    DELETE: 'DELETE',\n    SWITCH_PREV: 'SWITCH_PREV',\n    SWITCH_NEXT: 'SWITCH_NEXT',\n    TAB: 'TAB'\n};\nvar KEY_PRESS_ACTIONS = {\n    8: ACTIONS_KEYS.DELETE,\n    37: ACTIONS_KEYS.SWITCH_PREV,\n    39: ACTIONS_KEYS.SWITCH_NEXT,\n    9: ACTIONS_KEYS.TAB\n};\nvar DRAG_AND_DROP_KEY = 'Text';\nvar NEXT = 'NEXT';\nvar PREV = 'PREV';\nvar DragProvider = /*@__PURE__*/ (function () {\n    function DragProvider() {\n        this.state = {\n            dragging: false,\n            dropping: false,\n            index: undefined\n        };\n    }\n    /**\n     * \\@name setDraggedItem\n     * @param {?} event\n     * @param {?} tag\n     * @return {?}\n     */\n    DragProvider.prototype.setDraggedItem = function (event, tag) {\n        event.dataTransfer.setData(DRAG_AND_DROP_KEY, JSON.stringify(tag));\n    };\n    /**\n     * \\@name getDraggedItem\n     * @param {?} event\n     * @return {?}\n     */\n    DragProvider.prototype.getDraggedItem = function (event) {\n        var /** @type {?} */ data = event.dataTransfer.getData(DRAG_AND_DROP_KEY);\n        return (JSON.parse(data));\n    };\n    /**\n     * \\@name setSender\n     * @param {?} sender\n     * @return {?}\n     */\n    DragProvider.prototype.setSender = function (sender) {\n        this.sender = sender;\n    };\n    /**\n     * \\@name setReceiver\n     * @param {?} receiver\n     * @return {?}\n     */\n    DragProvider.prototype.setReceiver = function (receiver) {\n        this.receiver = receiver;\n    };\n    /**\n     * \\@name onTagDropped\n     * @param {?} tag\n     * @param {?} indexDragged\n     * @param {?} indexDropped\n     * @return {?}\n     */\n    DragProvider.prototype.onTagDropped = function (tag, indexDragged, indexDropped) {\n        this.onDragEnd();\n        this.sender.onRemoveRequested(tag, indexDragged);\n        this.receiver.onAddingRequested(false, tag, indexDropped);\n    };\n    /**\n     * \\@name setState\n     * @param {?} state\n     * @return {?}\n     */\n    DragProvider.prototype.setState = function (state$$1) {\n        this.state = Object.assign({}, this.state, state$$1);\n    };\n    /**\n     * \\@name getState\n     * @param {?=} key\n     * @return {?}\n     */\n    DragProvider.prototype.getState = function (key) {\n        return key ? this.state[key] : this.state;\n    };\n    /**\n     * \\@name onDragEnd\n     * @return {?}\n     */\n    DragProvider.prototype.onDragEnd = function () {\n        this.setState({\n            dragging: false,\n            dropping: false,\n            index: undefined\n        });\n    };\n    return DragProvider;\n}());\nvar defaults = {\n    tagInput: /** @type {?} */ ({\n        separatorKeys: [],\n        separatorKeyCodes: [],\n        maxItems: Infinity,\n        placeholder: PLACEHOLDER,\n        secondaryPlaceholder: SECONDARY_PLACEHOLDER,\n        validators: [],\n        asyncValidators: [],\n        onlyFromAutocomplete: false,\n        errorMessages: {},\n        theme: '',\n        onTextChangeDebounce: 250,\n        inputId: '',\n        inputClass: '',\n        clearOnBlur: false,\n        hideForm: false,\n        addOnBlur: false,\n        addOnPaste: false,\n        pasteSplitPattern: ',',\n        blinkIfDupe: true,\n        removable: true,\n        editable: false,\n        allowDupes: false,\n        modelAsStrings: false,\n        trimTags: true,\n        ripple: true,\n        tabIndex: '',\n        disable: false,\n        dragZone: '',\n        onRemoving: undefined,\n        onAdding: undefined,\n        displayBy: 'display',\n        identifyBy: 'value',\n        animationDuration: {\n            enter: \"250ms\",\n            leave: \"150ms\"\n        }\n    }),\n    dropdown: /** @type {?} */ ({\n        displayBy: 'display',\n        identifyBy: 'value',\n        appendToBody: true,\n        offset: '50 0',\n        focusFirstElement: false,\n        showDropdownIfEmpty: false,\n        minimumTextLength: 1,\n        limitItemsTo: Infinity,\n        keepOpen: true,\n        matchingFn: matchingFn\n    })\n};\n/**\n * \\@name matchingFn\n * @this {?}\n * @param {?} value\n * @param {?} target\n * @return {?}\n */\nfunction matchingFn(value, target) {\n    var /** @type {?} */ targetValue = target[this.displayBy].toString();\n    return targetValue && targetValue\n        .toLowerCase()\n        .indexOf(value.toLowerCase()) >= 0;\n}\nvar OptionsProvider = /*@__PURE__*/ (function () {\n    function OptionsProvider() {\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    OptionsProvider.prototype.setOptions = function (options) {\n        OptionsProvider.defaults.tagInput = Object.assign({}, defaults.tagInput, options.tagInput);\n        OptionsProvider.defaults.dropdown = Object.assign({}, defaults.dropdown, options.dropdown);\n    };\n    OptionsProvider.defaults = defaults;\n    return OptionsProvider;\n}());\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction isObject(obj) {\n    return obj === Object(obj);\n}\nvar TagInputAccessor = /*@__PURE__*/ (function () {\n    function TagInputAccessor() {\n        this._items = [];\n        /**\n         * \\@name displayBy\n         */\n        this.displayBy = OptionsProvider.defaults.tagInput.displayBy;\n        /**\n         * \\@name identifyBy\n         */\n        this.identifyBy = OptionsProvider.defaults.tagInput.identifyBy;\n    }\n    Object.defineProperty(TagInputAccessor.prototype, \"items\", {\n        /**\n         * @return {?}\n         */\n        get: function () {\n            return this._items;\n        },\n        /**\n         * @param {?} items\n         * @return {?}\n         */\n        set: function (items) {\n            this._items = items;\n            this._onChangeCallback(this._items);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    /**\n     * @return {?}\n     */\n    TagInputAccessor.prototype.onTouched = function () {\n        this._onTouchedCallback();\n    };\n    /**\n     * @param {?} items\n     * @return {?}\n     */\n    TagInputAccessor.prototype.writeValue = function (items) {\n        this._items = items || [];\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    TagInputAccessor.prototype.registerOnChange = function (fn) {\n        this._onChangeCallback = fn;\n    };\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    TagInputAccessor.prototype.registerOnTouched = function (fn) {\n        this._onTouchedCallback = fn;\n    };\n    /**\n     * \\@name getItemValue\n     * @param {?} item\n     * @return {?}\n     */\n    TagInputAccessor.prototype.getItemValue = function (item) {\n        return isObject(item) ? item[this.identifyBy] : item;\n    };\n    /**\n     * \\@name getItemDisplay\n     * @param {?} item\n     * @return {?}\n     */\n    TagInputAccessor.prototype.getItemDisplay = function (item) {\n        return isObject(item) ? item[this.displayBy] : item;\n    };\n    /**\n     * \\@name getItemsWithout\n     * @param {?} index\n     * @return {?}\n     */\n    TagInputAccessor.prototype.getItemsWithout = function (index) {\n        return this.items.filter(function (item, position) { return position !== index; });\n    };\n    return TagInputAccessor;\n}());\n/**\n * \\@name listen\n * @param {?} listenerType\n * @param {?} action\n * @param {?=} condition\n * @return {?}\n */\nfunction listen(listenerType, action, condition) {\n    if (condition === void 0) {\n        condition = true;\n    }\n    // if the event provided does not exist, throw an error\n    if (!this.listeners.hasOwnProperty(listenerType)) {\n        throw new Error('The event entered may be wrong');\n    }\n    // if a condition is present and is false, exit early\n    if (!condition) {\n        return;\n    }\n    // fire listener\n    this.listeners[listenerType].push(action);\n}\nvar TagInputForm = /*@__PURE__*/ (function () {\n    function TagInputForm() {\n        /**\n         * \\@name onSubmit\n         */\n        this.onSubmit = new EventEmitter();\n        /**\n         * \\@name onBlur\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * \\@name onFocus\n         */\n        this.onFocus = new EventEmitter();\n        /**\n         * \\@name onKeyup\n         */\n        this.onKeyup = new EventEmitter();\n        /**\n         * \\@name onKeydown\n         */\n        this.onKeydown = new EventEmitter();\n        /**\n         * \\@name validators\n         */\n        this.validators = [];\n        /**\n         * \\@name asyncValidators\n         * @desc array of AsyncValidator that are used to validate the tag before it gets appended to the list\n         */\n        this.asyncValidators = [];\n        /**\n         * \\@name tabindex\n         * @desc pass through the specified tabindex to the input\n         */\n        this.tabindex = '';\n        /**\n         * \\@name disabled\n         */\n        this.disabled = false;\n        /**\n         * \\@name inputTextChange\n         */\n        this.inputTextChange = new EventEmitter();\n        /**\n         * \\@name inputTextValue\n         */\n        this.inputTextValue = '';\n    }\n    Object.defineProperty(TagInputForm.prototype, \"inputText\", {\n        /**\n         * \\@name inputText\n         * @return {?}\n         */\n        get: function () {\n            return this.inputTextValue;\n        },\n        /**\n         * \\@name inputText\n         * @param {?} text {string}\n         * @return {?}\n         */\n        set: function (text) {\n            this.inputTextValue = text;\n            this.inputTextChange.emit(text);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * @return {?}\n     */\n    TagInputForm.prototype.ngOnInit = function () {\n        // creating form\n        this.form = new FormGroup({\n            item: new FormControl({ value: '', disabled: this.disabled }, this.validators, this.asyncValidators)\n        });\n    };\n    Object.defineProperty(TagInputForm.prototype, \"value\", {\n        /**\n         * \\@name value\n         * @return {?}\n         */\n        get: function () {\n            return this.form.get('item');\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * \\@name isInputFocused\n     * @return {?}\n     */\n    TagInputForm.prototype.isInputFocused = function () {\n        return document.activeElement === this.input.nativeElement;\n    };\n    /**\n     * \\@name getErrorMessages\n     * @param {?} messages\n     * @return {?}\n     */\n    TagInputForm.prototype.getErrorMessages = function (messages) {\n        var /** @type {?} */ value = this.value;\n        return value ? Object.keys(messages)\n            .filter(function (err) { return value.hasError(err); })\n            .map(function (err) { return messages[err]; }) : [];\n    };\n    /**\n     * \\@name hasErrors\n     * @return {?}\n     */\n    TagInputForm.prototype.hasErrors = function () {\n        return this.form.dirty &&\n            this.form.value.item &&\n            this.form.invalid;\n    };\n    /**\n     * \\@name focus\n     * @return {?}\n     */\n    TagInputForm.prototype.focus = function () {\n        this.input.nativeElement.focus();\n    };\n    /**\n     * \\@name blur\n     * @return {?}\n     */\n    TagInputForm.prototype.blur = function () {\n        this.input.nativeElement.blur();\n    };\n    /**\n     * \\@name getElementPosition\n     * @return {?}\n     */\n    TagInputForm.prototype.getElementPosition = function () {\n        return this.input.nativeElement.getBoundingClientRect();\n    };\n    /**\n     * - removes input from the component\n     * \\@name destroy\n     * @return {?}\n     */\n    TagInputForm.prototype.destroy = function () {\n        var /** @type {?} */ input = this.input.nativeElement;\n        input.parentElement.removeChild(input);\n    };\n    /**\n     * \\@name onKeyDown\n     * @param {?} $event\n     * @return {?}\n     */\n    TagInputForm.prototype.onKeyDown = function ($event) {\n        return this.onKeydown.emit($event);\n    };\n    /**\n     * \\@name submit\n     * @param {?} $event\n     * @return {?}\n     */\n    TagInputForm.prototype.submit = function ($event) {\n        this.onSubmit.emit($event);\n    };\n    return TagInputForm;\n}());\nvar defaults$2 = forwardRef(function () { return OptionsProvider.defaults.dropdown; });\nvar TagInputDropdown = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} injector\n     */\n    function TagInputDropdown(injector) {\n        var _this = this;\n        this.injector = injector;\n        /**\n         * \\@name offset\n         */\n        this.offset = new defaults$2().offset;\n        /**\n         * \\@name focusFirstElement\n         */\n        this.focusFirstElement = new defaults$2().focusFirstElement;\n        /**\n         * - show autocomplete dropdown if the value of input is empty\n         * \\@name showDropdownIfEmpty\n         */\n        this.showDropdownIfEmpty = new defaults$2().showDropdownIfEmpty;\n        /**\n         * - desc minimum text length in order to display the autocomplete dropdown\n         * \\@name minimumTextLength\n         */\n        this.minimumTextLength = new defaults$2().minimumTextLength;\n        /**\n         * - number of items to display in the autocomplete dropdown\n         * \\@name limitItemsTo\n         */\n        this.limitItemsTo = new defaults$2().limitItemsTo;\n        /**\n         * \\@name displayBy\n         */\n        this.displayBy = new defaults$2().displayBy;\n        /**\n         * \\@name identifyBy\n         */\n        this.identifyBy = new defaults$2().identifyBy;\n        /**\n         * \\@description a function a developer can use to implement custom matching for the autocomplete\n         * \\@name matchingFn\n         */\n        this.matchingFn = new defaults$2().matchingFn;\n        /**\n         * \\@name appendToBody\n         */\n        this.appendToBody = new defaults$2().appendToBody;\n        /**\n         * \\@name keepOpen\n         * \\@description option to leave dropdown open when adding a new item\n         */\n        this.keepOpen = new defaults$2().keepOpen;\n        /**\n         * list of items that match the current value of the input (for autocomplete)\n         * \\@name items\n         */\n        this.items = [];\n        /**\n         * \\@name tagInput\n         */\n        this.tagInput = this.injector.get(TagInputComponent);\n        /**\n         * \\@name _autocompleteItems\n         */\n        this._autocompleteItems = [];\n        /**\n         *\n         * \\@name show\n         */\n        this.show = function () {\n            var maxItemsReached = _this.tagInput.items.length === _this.tagInput.maxItems;\n            var value = _this.getFormValue();\n            var hasMinimumText = value.trim().length >= _this.minimumTextLength;\n            var position = _this.calculatePosition();\n            var items = _this.getMatchingItems(value);\n            var hasItems = items.length > 0;\n            var isHidden = _this.isVisible === false;\n            var showDropdownIfEmpty = _this.showDropdownIfEmpty && hasItems && !value;\n            var shouldShow = isHidden && ((hasItems && hasMinimumText) || showDropdownIfEmpty);\n            var shouldHide = _this.isVisible && !hasItems;\n            if (_this.autocompleteObservable && hasMinimumText) {\n                return _this.getItemsFromObservable(value);\n            }\n            if (!_this.showDropdownIfEmpty && !value) {\n                return _this.dropdown.hide();\n            }\n            if (maxItemsReached) {\n                return _this.dropdown.hide();\n            }\n            _this.setItems(items);\n            if (shouldShow) {\n                _this.dropdown.show(position);\n            }\n            else if (shouldHide) {\n                _this.hide();\n            }\n        };\n        /**\n         * \\@name requestAdding\n         * @param item {Ng2MenuItem}\n         */\n        this.requestAdding = function (item) {\n            _this.tagInput.onAddingRequested(true, _this.createTagModel(item));\n        };\n        /**\n         * \\@name resetItems\n         */\n        this.resetItems = function () {\n            _this.items = [];\n        };\n        /**\n         * \\@name getItemsFromObservable\n         * @param text\n         */\n        this.getItemsFromObservable = function (text) {\n            _this.setLoadingState(true);\n            var subscribeFn = function (data) {\n                // hide loading animation\n                _this.setLoadingState(false)\n                    .populateItems(data);\n                _this.setItems(_this.getMatchingItems(text));\n                if (_this.items.length) {\n                    _this.dropdown.show(_this.calculatePosition());\n                }\n                else if (!_this.showDropdownIfEmpty && _this.isVisible) {\n                    _this.dropdown.hide();\n                }\n            };\n            _this.autocompleteObservable(text)\n                .first()\n                .subscribe(subscribeFn, function () { return _this.setLoadingState(false); });\n        };\n    }\n    Object.defineProperty(TagInputDropdown.prototype, \"autocompleteItems\", {\n        /**\n         * \\@name autocompleteItems\n         * @desc array of items that will populate the autocomplete\n         * @return {?}\n         */\n        get: function () {\n            var _this = this;\n            var /** @type {?} */ items = this._autocompleteItems;\n            if (!items) {\n                return [];\n            }\n            return items.map(function (item) {\n                return typeof item === 'string' ? (_a = {},\n                    _a[_this.displayBy] = item,\n                    _a[_this.identifyBy] = item,\n                    _a) : item;\n                var _a;\n            });\n        },\n        /**\n         * \\@name autocompleteItems\n         * @param {?} items\n         * @return {?}\n         */\n        set: function (items) {\n            this._autocompleteItems = items;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * \\@name ngOnInit\n     * @return {?}\n     */\n    TagInputDropdown.prototype.ngOnInit = function () {\n        this.onItemClicked().subscribe(this.requestAdding);\n        // reset itemsMatching array when the dropdown is hidden\n        this.onHide().subscribe(this.resetItems);\n        var /** @type {?} */ DEBOUNCE_TIME = 200;\n        var /** @type {?} */ KEEP_OPEN = this.keepOpen;\n        this.tagInput\n            .onTextChange\n            .asObservable()\n            .debounceTime(DEBOUNCE_TIME)\n            .filter(function (value) {\n            if (KEEP_OPEN === false) {\n                return value.length > 0;\n            }\n            return true;\n        })\n            .subscribe(this.show);\n    };\n    /**\n     * \\@name updatePosition\n     * @return {?}\n     */\n    TagInputDropdown.prototype.updatePosition = function () {\n        var /** @type {?} */ position = this.tagInput.inputForm.getElementPosition();\n        this.dropdown.menu.updatePosition(position);\n    };\n    Object.defineProperty(TagInputDropdown.prototype, \"isVisible\", {\n        /**\n         * \\@name isVisible\n         * @return {?}\n         */\n        get: function () {\n            return this.dropdown.menu.state.menuState.isVisible;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * \\@name onHide\n     * @return {?}\n     */\n    TagInputDropdown.prototype.onHide = function () {\n        return this.dropdown.onHide;\n    };\n    /**\n     * \\@name onItemClicked\n     * @return {?}\n     */\n    TagInputDropdown.prototype.onItemClicked = function () {\n        return this.dropdown.onItemClicked;\n    };\n    Object.defineProperty(TagInputDropdown.prototype, \"selectedItem\", {\n        /**\n         * \\@name selectedItem\n         * @return {?}\n         */\n        get: function () {\n            return this.dropdown.menu.state.dropdownState.selectedItem;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TagInputDropdown.prototype, \"state\", {\n        /**\n         * \\@name state\n         * @return {?}\n         */\n        get: function () {\n            return this.dropdown.menu.state;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * \\@name hide\n     * @return {?}\n     */\n    TagInputDropdown.prototype.hide = function () {\n        this.resetItems();\n        this.dropdown.hide();\n    };\n    /**\n     * \\@name scrollListener\n     * @return {?}\n     */\n    TagInputDropdown.prototype.scrollListener = function () {\n        if (!this.isVisible) {\n            return;\n        }\n        this.updatePosition();\n    };\n    /**\n     * \\@name onWindowBlur\n     * @return {?}\n     */\n    TagInputDropdown.prototype.onWindowBlur = function () {\n        this.dropdown.hide();\n    };\n    /**\n     * \\@name getFormValue\n     * @return {?}\n     */\n    TagInputDropdown.prototype.getFormValue = function () {\n        return this.tagInput.formValue.trim();\n    };\n    /**\n     * \\@name calculatePosition\n     * @return {?}\n     */\n    TagInputDropdown.prototype.calculatePosition = function () {\n        return this.tagInput.inputForm.getElementPosition();\n    };\n    /**\n     * \\@name createTagModel\n     * @param {?} item\n     * @return {?}\n     */\n    TagInputDropdown.prototype.createTagModel = function (item) {\n        var /** @type {?} */ display = typeof item.value === 'string' ? item.value : item.value[this.displayBy];\n        var /** @type {?} */ value = typeof item.value === 'string' ? item.value : item.value[this.identifyBy];\n        return Object.assign({}, item.value, (_a = {}, _a[this.tagInput.displayBy] = display, _a[this.tagInput.identifyBy] = value, _a));\n        var _a;\n    };\n    /**\n     *\n     * @param {?} value {string}\n     * @return {?}\n     */\n    TagInputDropdown.prototype.getMatchingItems = function (value) {\n        var _this = this;\n        if (!value && !this.showDropdownIfEmpty) {\n            return [];\n        }\n        var /** @type {?} */ dupesAllowed = this.tagInput.allowDupes;\n        return this.autocompleteItems.filter(function (item) {\n            var /** @type {?} */ hasValue = dupesAllowed ? false : _this.tagInput.tags.some(function (tag) {\n                var /** @type {?} */ identifyBy = _this.tagInput.identifyBy;\n                var /** @type {?} */ model = typeof tag.model === 'string' ? tag.model : tag.model[identifyBy];\n                return model === item[_this.identifyBy];\n            });\n            return _this.matchingFn(value, item) && (hasValue === false);\n        });\n    };\n    /**\n     * \\@name setItems\n     * @param {?} items\n     * @return {?}\n     */\n    TagInputDropdown.prototype.setItems = function (items) {\n        this.items = items.slice(0, this.limitItemsTo || items.length);\n    };\n    /**\n     * \\@name populateItems\n     * @param {?} data\n     * @return {?}\n     */\n    TagInputDropdown.prototype.populateItems = function (data) {\n        var _this = this;\n        this.autocompleteItems = data.map(function (item) {\n            return typeof item === 'string' ? (_a = {},\n                _a[_this.displayBy] = item,\n                _a[_this.identifyBy] = item,\n                _a) : item;\n            var _a;\n        });\n        return this;\n    };\n    /**\n     * \\@name setLoadingState\n     * @param {?} state\n     * @return {?}\n     */\n    TagInputDropdown.prototype.setLoadingState = function (state$$1) {\n        this.tagInput.isLoading = state$$1;\n        return this;\n    };\n    return TagInputDropdown;\n}());\nvar TagRipple = /*@__PURE__*/ (function () {\n    function TagRipple() {\n        this.state = 'none';\n    }\n    return TagRipple;\n}());\n// angular universal hacks\n/* tslint:disable-next-line */\nvar KeyboardEvent = ((global)).KeyboardEvent;\nvar MouseEvent = ((global)).MouseEvent;\n// mocking navigator\nvar navigator = typeof window !== 'undefined' ? window.navigator : {\n    userAgent: 'Chrome',\n    vendor: 'Google Inc'\n};\nvar isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);\nvar TagComponent = /*@__PURE__*/ (function () {\n    /**\n     * @param {?} element\n     * @param {?} renderer\n     * @param {?} cdRef\n     */\n    function TagComponent(element, renderer, cdRef) {\n        this.element = element;\n        this.renderer = renderer;\n        this.cdRef = cdRef;\n        /**\n         * \\@name disabled\n         */\n        this.disabled = false;\n        /**\n         * \\@name onSelect\n         */\n        this.onSelect = new EventEmitter();\n        /**\n         * \\@name onRemove\n         */\n        this.onRemove = new EventEmitter();\n        /**\n         * \\@name onBlur\n         */\n        this.onBlur = new EventEmitter();\n        /**\n         * \\@name onKeyDown\n         */\n        this.onKeyDown = new EventEmitter();\n        /**\n         * \\@name onTagEdited\n         */\n        this.onTagEdited = new EventEmitter();\n        /**\n         * \\@name editing\n         */\n        this.editing = false;\n        /**\n         * \\@name rippleState\n         */\n        this.rippleState = 'none';\n    }\n    Object.defineProperty(TagComponent.prototype, \"readonly\", {\n        /**\n         * \\@name readonly {boolean}\n         * @return {?}\n         */\n        get: function () {\n            return typeof this.model !== 'string' && this.model.readonly === true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ;\n    /**\n     * \\@name select\n     * @param {?=} $event\n     * @return {?}\n     */\n    TagComponent.prototype.select = function ($event) {\n        if (this.readonly || this.disabled) {\n            return;\n        }\n        if ($event) {\n            $event.stopPropagation();\n        }\n        this.focus();\n        this.onSelect.emit(this.model);\n    };\n    /**\n     * \\@name remove\n     * @param {?} $event\n     * @return {?}\n     */\n    TagComponent.prototype.remove = function ($event) {\n        $event.stopPropagation();\n        this.onRemove.emit(this);\n    };\n    /**\n     * \\@name focus\n     * @return {?}\n     */\n    TagComponent.prototype.focus = function () {\n        this.element.nativeElement.focus();\n    };\n    /**\n     * @return {?}\n     */\n    TagComponent.prototype.move = function () {\n        this.moving = true;\n    };\n    /**\n     * \\@name keydown\n     * @param {?} event\n     * @return {?}\n     */\n    TagComponent.prototype.keydown = function (event) {\n        if (this.editing) {\n            event.keyCode === 13 ? this.disableEditMode(event) : undefined;\n            return;\n        }\n        this.onKeyDown.emit({ event: event, model: this.model });\n    };\n    /**\n     * \\@name blink\n     * @return {?}\n     */\n    TagComponent.prototype.blink = function () {\n        var /** @type {?} */ classList = this.element.nativeElement.classList;\n        classList.add('blink');\n        setTimeout(function () { return classList.remove('blink'); }, 50);\n    };\n    /**\n     * \\@name toggleEditMode\n     * @return {?}\n     */\n    TagComponent.prototype.toggleEditMode = function () {\n        if (this.editable) {\n            this.editing ? undefined : this.activateEditMode();\n        }\n    };\n    /**\n     * \\@name onBlurred\n     * @param {?} event\n     * @return {?}\n     */\n    TagComponent.prototype.onBlurred = function (event) {\n        // Checks if it is editable first before handeling the onBlurred event in order to prevent\n        // a bug in IE where tags are still editable with onlyFromAutocomplete set to true\n        if (!this.editable) {\n            return;\n        }\n        this.disableEditMode();\n        var /** @type {?} */ value = event.target.innerText;\n        var /** @type {?} */ result = typeof this.model === 'string' ? value : Object.assign({}, this.model, (_a = {}, _a[this.displayBy] = value, _a));\n        this.onBlur.emit(result);\n        var _a;\n    };\n    /**\n     * \\@name getDisplayValue\n     * @param {?} item\n     * @return {?}\n     */\n    TagComponent.prototype.getDisplayValue = function (item) {\n        return typeof item === 'string' ? item : item[this.displayBy];\n    };\n    Object.defineProperty(TagComponent.prototype, \"isRippleVisible\", {\n        /**\n         * @desc returns whether the ripple is visible or not\n         * only works in Chrome\n         * \\@name isRippleVisible\n         * @return {?}\n         */\n        get: function () {\n            return !this.readonly &&\n                !this.editing &&\n                isChrome &&\n                this.hasRipple;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * \\@name disableEditMode\n     * @param {?=} $event\n     * @return {?}\n     */\n    TagComponent.prototype.disableEditMode = function ($event) {\n        var /** @type {?} */ classList = this.element.nativeElement.classList;\n        var /** @type {?} */ input = this.getContentEditableText();\n        this.editing = false;\n        classList.remove('tag--editing');\n        if (!input) {\n            this.setContentEditableText(this.model);\n            return;\n        }\n        this.storeNewValue(input);\n        this.cdRef.detectChanges();\n        if ($event) {\n            $event.preventDefault();\n        }\n    };\n    /**\n     * \\@name isDeleteIconVisible\n     * @return {?}\n     */\n    TagComponent.prototype.isDeleteIconVisible = function () {\n        return !this.readonly &&\n            !this.disabled &&\n            this.removable &&\n            !this.editing;\n    };\n    /**\n     * \\@name getContentEditableText\n     * @return {?}\n     */\n    TagComponent.prototype.getContentEditableText = function () {\n        var /** @type {?} */ input = this.getContentEditable();\n        return input ? input.innerText.trim() : '';\n    };\n    /**\n     * \\@name setContentEditableText\n     * @param {?} model\n     * @return {?}\n     */\n    TagComponent.prototype.setContentEditableText = function (model) {\n        var /** @type {?} */ input = this.getContentEditable();\n        var /** @type {?} */ value = this.getDisplayValue(model);\n        input.innerText = value;\n    };\n    /**\n     * \\@name\n     * @return {?}\n     */\n    TagComponent.prototype.activateEditMode = function () {\n        var /** @type {?} */ classList = this.element.nativeElement.classList;\n        classList.add('tag--editing');\n        this.editing = true;\n    };\n    /**\n     * \\@name storeNewValue\n     * @param {?} input\n     * @return {?}\n     */\n    TagComponent.prototype.storeNewValue = function (input) {\n        var _this = this;\n        var /** @type {?} */ exists = function (model) {\n            return typeof model === 'string' ?\n                model === input :\n                model[_this.displayBy] === input;\n        };\n        var /** @type {?} */ hasId = function () {\n            return _this.model[_this.identifyBy] !== _this.model[_this.displayBy];\n        };\n        // if the value changed, replace the value in the model\n        if (exists(this.model)) {\n            return;\n        }\n        var /** @type {?} */ model = typeof this.model === 'string' ? input : (_a = {},\n            _a[this.identifyBy] = hasId() ? this.model[this.identifyBy] : input,\n            _a[this.displayBy] = input,\n            _a);\n        // emit output\n        this.model = model;\n        this.onTagEdited.emit(model);\n        var _a;\n    };\n    /**\n     * \\@name getContentEditable\n     * @return {?}\n     */\n    TagComponent.prototype.getContentEditable = function () {\n        return this.element.nativeElement.querySelector('[contenteditable]');\n    };\n    return TagComponent;\n}());\n/**\n * \\@name animations\n */\nvar animations$1 = [\n    trigger$1('animation', [\n        state$1('in', style$1({\n            opacity: 1\n        })),\n        state$1('out', style$1({\n            opacity: 0\n        })),\n        transition$1(':enter', [\n            animate$1(\"{{ enter }}\", keyframes$1([\n                style$1({ opacity: 0, offset: 0, transform: 'translate(0px, 20px)' }),\n                style$1({ opacity: 0.3, offset: 0.3, transform: 'translate(0px, -10px)' }),\n                style$1({ opacity: 0.5, offset: 0.5, transform: 'translate(0px, 0px)' }),\n                style$1({ opacity: 0.75, offset: 0.75, transform: 'translate(0px, 5px)' }),\n                style$1({ opacity: 1, offset: 1, transform: 'translate(0px, 0px)' })\n            ]))\n        ]),\n        transition$1(':leave', [\n            animate$1(\"{{ leave }}\", keyframes$1([\n                style$1({ opacity: 1, transform: 'translateX(0)', offset: 0 }),\n                style$1({ opacity: 1, transform: 'translateX(-15px)', offset: 0.7 }),\n                style$1({ opacity: 0, transform: 'translateX(100%)', offset: 1.0 })\n            ]))\n        ])\n    ])\n];\n// angular\n// rx\n// ng2-tag-input\n// angular universal hacks\n/* tslint:disable-next-line */\nvar DragEvent = ((global)).DragEvent;\nvar CUSTOM_ACCESSOR = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(function () { return TagInputComponent; }),\n    multi: true\n};\nvar defaults$1 = forwardRef(function () { return OptionsProvider.defaults.tagInput; });\nvar TagInputComponent = /*@__PURE__*/ (function (_super) {\n    __extends(TagInputComponent, _super);\n    /**\n     * @param {?} renderer\n     * @param {?} dragProvider\n     */\n    function TagInputComponent(renderer, dragProvider) {\n        var _this = _super.call(this) || this;\n        _this.renderer = renderer;\n        _this.dragProvider = dragProvider;\n        /**\n         * \\@name separatorKeys\n         * @desc keyboard keys with which a user can separate items\n         */\n        _this.separatorKeys = new defaults$1().separatorKeys;\n        /**\n         * \\@name separatorKeyCodes\n         * @desc keyboard key codes with which a user can separate items\n         */\n        _this.separatorKeyCodes = new defaults$1().separatorKeyCodes;\n        /**\n         * \\@name placeholder\n         * @desc the placeholder of the input text\n         */\n        _this.placeholder = new defaults$1().placeholder;\n        /**\n         * \\@name secondaryPlaceholder\n         * @desc placeholder to appear when the input is empty\n         */\n        _this.secondaryPlaceholder = new defaults$1().secondaryPlaceholder;\n        /**\n         * \\@name maxItems\n         * @desc maximum number of items that can be added\n         */\n        _this.maxItems = new defaults$1().maxItems;\n        /**\n         * \\@name validators\n         * @desc array of Validators that are used to validate the tag before it gets appended to the list\n         */\n        _this.validators = new defaults$1().validators;\n        /**\n         * \\@name asyncValidators\n         * @desc array of AsyncValidator that are used to validate the tag before it gets appended to the list\n         */\n        _this.asyncValidators = new defaults$1().asyncValidators;\n        /**\n         * - if set to true, it will only possible to add items from the autocomplete\n         * \\@name onlyFromAutocomplete\n         */\n        _this.onlyFromAutocomplete = new defaults$1().onlyFromAutocomplete;\n        /**\n         * \\@name errorMessages\n         */\n        _this.errorMessages = new defaults$1().errorMessages;\n        /**\n         * \\@name theme\n         */\n        _this.theme = new defaults$1().theme;\n        /**\n         * \\@name onTextChangeDebounce\n         */\n        _this.onTextChangeDebounce = new defaults$1().onTextChangeDebounce;\n        /**\n         * - custom id assigned to the input\n         * \\@name id\n         */\n        _this.inputId = new defaults$1().inputId;\n        /**\n         * - custom class assigned to the input\n         */\n        _this.inputClass = new defaults$1().inputClass;\n        /**\n         * - option to clear text input when the form is blurred\n         * \\@name clearOnBlur\n         */\n        _this.clearOnBlur = new defaults$1().clearOnBlur;\n        /**\n         * - hideForm\n         * \\@name clearOnBlur\n         */\n        _this.hideForm = new defaults$1().hideForm;\n        /**\n         * \\@name addOnBlur\n         */\n        _this.addOnBlur = new defaults$1().addOnBlur;\n        /**\n         * \\@name addOnPaste\n         */\n        _this.addOnPaste = new defaults$1().addOnPaste;\n        /**\n         * - pattern used with the native method split() to separate patterns in the string pasted\n         * \\@name pasteSplitPattern\n         */\n        _this.pasteSplitPattern = new defaults$1().pasteSplitPattern;\n        /**\n         * \\@name blinkIfDupe\n         */\n        _this.blinkIfDupe = new defaults$1().blinkIfDupe;\n        /**\n         * \\@name removable\n         */\n        _this.removable = new defaults$1().removable;\n        /**\n         * \\@name editable\n         */\n        _this.editable = new defaults$1().editable;\n        /**\n         * \\@name allowDupes\n         */\n        _this.allowDupes = new defaults$1().allowDupes;\n        /**\n         * \\@description if set to true, the newly added tags will be added as strings, and not objects\n         * \\@name modelAsStrings\n         */\n        _this.modelAsStrings = new defaults$1().modelAsStrings;\n        /**\n         * \\@name trimTags\n         */\n        _this.trimTags = new defaults$1().trimTags;\n        /**\n         * \\@name ripple\n         */\n        _this.ripple = new defaults$1().ripple;\n        /**\n         * \\@name tabindex\n         * @desc pass through the specified tabindex to the input\n         */\n        _this.tabindex = new defaults$1().tabIndex;\n        /**\n         * \\@name disable\n         */\n        _this.disable = new defaults$1().disable;\n        /**\n         * \\@name dragZone\n         */\n        _this.dragZone = new defaults$1().dragZone;\n        /**\n         * \\@name onRemoving\n         */\n        _this.onRemoving = new defaults$1().onRemoving;\n        /**\n         * \\@name onAdding\n         */\n        _this.onAdding = new defaults$1().onAdding;\n        /**\n         * \\@name animationDuration\n         */\n        _this.animationDuration = new defaults$1().animationDuration;\n        /**\n         * \\@name onAdd\n         * @desc event emitted when adding a new item\n         */\n        _this.onAdd = new EventEmitter();\n        /**\n         * \\@name onRemove\n         * @desc event emitted when removing an existing item\n         */\n        _this.onRemove = new EventEmitter();\n        /**\n         * \\@name onSelect\n         * @desc event emitted when selecting an item\n         */\n        _this.onSelect = new EventEmitter();\n        /**\n         * \\@name onFocus\n         * @desc event emitted when the input is focused\n         */\n        _this.onFocus = new EventEmitter();\n        /**\n         * \\@name onFocus\n         * @desc event emitted when the input is blurred\n         */\n        _this.onBlur = new EventEmitter();\n        /**\n         * \\@name onTextChange\n         * @desc event emitted when the input value changes\n         */\n        _this.onTextChange = new EventEmitter();\n        /**\n         * - output triggered when text is pasted in the form\n         * \\@name onPaste\n         */\n        _this.onPaste = new EventEmitter();\n        /**\n         * - output triggered when tag entered is not valid\n         * \\@name onValidationError\n         */\n        _this.onValidationError = new EventEmitter();\n        /**\n         * - output triggered when tag is edited\n         * \\@name onTagEdited\n         */\n        _this.onTagEdited = new EventEmitter();\n        /**\n         * \\@name isLoading\n         */\n        _this.isLoading = false;\n        /**\n         * \\@name listeners\n         * @desc array of events that get fired using \\@fireEvents\n         */\n        _this.listeners = (_a = {},\n            _a[KEYDOWN] = [],\n            _a[KEYUP] = [],\n            _a);\n        /**\n         * \\@description emitter for the 2-way data binding inputText value\n         * \\@name inputTextChange\n         */\n        _this.inputTextChange = new EventEmitter();\n        /**\n         * \\@description private variable to bind get/set\n         * \\@name inputTextValue\n         */\n        _this.inputTextValue = '';\n        /**\n         * \\@name appendTag\n         * @param tag {TagModel}\n         */\n        _this.appendTag = function (tag, index) {\n            if (index === void 0) {\n                index = _this.items.length;\n            }\n            var items = _this.items;\n            var model = _this.modelAsStrings ? tag[_this.identifyBy] : tag;\n            _this.items = items.slice(0, index).concat([\n                model\n            ], items.slice(index, items.length));\n        };\n        /**\n         * \\@name createTag\n         * @param model\n         */\n        _this.createTag = function (model) {\n            var trim = function (val, key) {\n                return typeof val === 'string' ? val.trim() : val[key];\n            };\n            return Object.assign({}, typeof model !== 'string' ? model : {}, (_a = {}, _a[_this.displayBy] = _this.trimTags ? trim(model, _this.displayBy) : model, _a[_this.identifyBy] = _this.trimTags ? trim(model, _this.identifyBy) : model, _a));\n            var _a;\n        };\n        /**\n         * \\@name onPasteCallback\n         * @param data\n         */\n        _this.onPasteCallback = function (data) {\n            var text = data.clipboardData.getData('text/plain');\n            text.split(_this.pasteSplitPattern)\n                .map(function (item) { return _this.createTag(item); })\n                .forEach(function (item) { return _this.onAddingRequested(false, item); });\n            _this.onPaste.emit(text);\n            setTimeout(function () { return _this.setInputValue(''); }, 0);\n        };\n        return _this;\n        var _a;\n    }\n    Object.defineProperty(TagInputComponent.prototype, \"inputText\", {\n        /**\n         * \\@name inputText\n         * @return {?}\n         */\n        get: function () {\n            return this.inputTextValue;\n        },\n        /**\n         * \\@name inputText\n         * @param {?} text\n         * @return {?}\n         */\n        set: function (text) {\n            this.inputTextValue = text;\n            this.inputTextChange.emit(text);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TagInputComponent.prototype, \"tabindexAttr\", {\n        /**\n         * @desc removes the tab index if it is set - it will be passed through to the input\n         * \\@name tabindexAttr\n         * @return {?}\n         */\n        get: function () {\n            return this.tabindex !== '' ? '-1' : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * \\@name ngAfterViewInit\n     * @return {?}\n     */\n    TagInputComponent.prototype.ngAfterViewInit = function () {\n        // set up listeners\n        this.setUpKeypressListeners();\n        this.setupSeparatorKeysListener();\n        this.setUpInputKeydownListeners();\n        if (this.onTextChange.observers.length) {\n            this.setUpTextChangeSubscriber();\n        }\n        // if clear on blur is set to true, subscribe to the event and clear the text's form\n        if (this.clearOnBlur || this.addOnBlur) {\n            this.setUpOnBlurSubscriber();\n        }\n        // if addOnPaste is set to true, register the handler and add items\n        if (this.addOnPaste) {\n            this.setUpOnPasteListener();\n        }\n        // if hideForm is set to true, remove the input\n        if (this.hideForm) {\n            this.inputForm.destroy();\n        }\n    };\n    /**\n     * \\@name ngOnInit\n     * @return {?}\n     */\n    TagInputComponent.prototype.ngOnInit = function () {\n        // if the number of items specified in the model is > of the value of maxItems\n        // degrade gracefully and let the max number of items to be the number of items in the model\n        // though, warn the user.\n        var /** @type {?} */ hasReachedMaxItems = this.maxItems !== undefined &&\n            this.items &&\n            this.items.length > this.maxItems;\n        if (hasReachedMaxItems) {\n            this.maxItems = this.items.length;\n            console.warn(MAX_ITEMS_WARNING);\n        }\n        // Setting editable to false to fix problem with tags in IE still being editable when\n        // onlyFromAutocomplete is true\n        this.editable = this.onlyFromAutocomplete ? false : this.editable;\n        this.setAnimationMetadata();\n    };\n    /**\n     * \\@name onRemoveRequested\n     * @param {?} tag\n     * @param {?} index\n     * @return {?}\n     */\n    TagInputComponent.prototype.onRemoveRequested = function (tag, index) {\n        var _this = this;\n        var /** @type {?} */ subscribeFn = function (model) { return _this.removeItem(model, index); };\n        this.onRemoving ?\n            this.onRemoving(tag)\n                .first()\n                .subscribe(subscribeFn) : subscribeFn(tag);\n    };\n    /**\n     * \\@name onAddingRequested\n     * @param {?} fromAutocomplete {boolean}\n     * @param {?} tag {TagModel}\n     * @param {?=} index\n     * @return {?}\n     */\n    TagInputComponent.prototype.onAddingRequested = function (fromAutocomplete, tag, index) {\n        var _this = this;\n        if (!tag) {\n            return;\n        }\n        var /** @type {?} */ subscribeFn = function (model) {\n            return _this.addItem(fromAutocomplete, model, index);\n        };\n        this.onAdding ?\n            this.onAdding(tag)\n                .first()\n                .subscribe(subscribeFn) : subscribeFn(tag);\n    };\n    /**\n     * \\@name selectItem\n     * @desc selects item passed as parameter as the selected tag\n     * @param {?} item\n     * @param {?=} emit\n     * @return {?}\n     */\n    TagInputComponent.prototype.selectItem = function (item, emit) {\n        if (emit === void 0) {\n            emit = true;\n        }\n        var /** @type {?} */ isReadonly = item && typeof item !== 'string' && item.readonly;\n        if (isReadonly || this.selectedTag === item) {\n            return;\n        }\n        this.selectedTag = item;\n        if (emit) {\n            this.onSelect.emit(item);\n        }\n    };\n    /**\n     * \\@name fireEvents\n     * @desc goes through the list of the events for a given eventName, and fires each of them\n     * @param {?} eventName\n     * @param {?=} $event\n     * @return {?}\n     */\n    TagInputComponent.prototype.fireEvents = function (eventName, $event) {\n        var _this = this;\n        this.listeners[eventName].forEach(function (listener) { return listener.call(_this, $event); });\n    };\n    /**\n     * \\@name handleKeydown\n     * @desc handles action when the user hits a keyboard key\n     * @param {?} data\n     * @return {?}\n     */\n    TagInputComponent.prototype.handleKeydown = function (data) {\n        var /** @type {?} */ event = data.event;\n        var /** @type {?} */ key = event.keyCode || event.which;\n        switch (KEY_PRESS_ACTIONS[key]) {\n            case ACTIONS_KEYS.DELETE:\n                if (this.selectedTag && this.removable) {\n                    var /** @type {?} */ index = this.items.indexOf(this.selectedTag);\n                    this.onRemoveRequested(this.selectedTag, index);\n                }\n                break;\n            case ACTIONS_KEYS.SWITCH_PREV:\n                this.moveToTag(data.model, PREV);\n                break;\n            case ACTIONS_KEYS.SWITCH_NEXT:\n                this.moveToTag(data.model, NEXT);\n                break;\n            case ACTIONS_KEYS.TAB:\n                this.moveToTag(data.model, NEXT);\n                break;\n            default:\n                return;\n        }\n        // prevent default behaviour\n        event.preventDefault();\n    };\n    /**\n     * \\@name setInputValue\n     * @param {?} value\n     * @return {?}\n     */\n    TagInputComponent.prototype.setInputValue = function (value) {\n        var /** @type {?} */ control = this.getControl();\n        // update form value with the transformed item\n        control.setValue(value);\n    };\n    /**\n     * \\@name getControl\n     * @return {?}\n     */\n    TagInputComponent.prototype.getControl = function () {\n        return (this.inputForm.value);\n    };\n    /**\n     * \\@name focus\n     * @param {?=} applyFocus\n     * @param {?=} displayAutocomplete\n     * @return {?}\n     */\n    TagInputComponent.prototype.focus = function (applyFocus, displayAutocomplete) {\n        if (applyFocus === void 0) {\n            applyFocus = false;\n        }\n        if (displayAutocomplete === void 0) {\n            displayAutocomplete = false;\n        }\n        if (this.dragProvider.getState('dragging')) {\n            return;\n        }\n        this.selectItem(undefined, false);\n        if (applyFocus) {\n            this.inputForm.focus();\n            this.onFocus.emit(this.formValue);\n        }\n    };\n    /**\n     * \\@name blur\n     * @return {?}\n     */\n    TagInputComponent.prototype.blur = function () {\n        this.onTouched();\n        this.onBlur.emit(this.formValue);\n    };\n    /**\n     * \\@name hasErrors\n     * @return {?}\n     */\n    TagInputComponent.prototype.hasErrors = function () {\n        return this.inputForm && this.inputForm.hasErrors();\n    };\n    /**\n     * \\@name isInputFocused\n     * @return {?}\n     */\n    TagInputComponent.prototype.isInputFocused = function () {\n        return this.inputForm && this.inputForm.isInputFocused();\n    };\n    /**\n     * - this is the one way I found to tell if the template has been passed and it is not\n     * the template for the menu item\n     * \\@name hasCustomTemplate\n     * @return {?}\n     */\n    TagInputComponent.prototype.hasCustomTemplate = function () {\n        var /** @type {?} */ template = this.templates ? this.templates.first : undefined;\n        var /** @type {?} */ menuTemplate = this.dropdown && this.dropdown.templates ?\n            this.dropdown.templates.first : undefined;\n        return Boolean(template && template !== menuTemplate);\n    };\n    Object.defineProperty(TagInputComponent.prototype, \"maxItemsReached\", {\n        /**\n         * \\@name maxItemsReached\n         * @return {?}\n         */\n        get: function () {\n            return this.maxItems !== undefined &&\n                this.items.length >= this.maxItems;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(TagInputComponent.prototype, \"formValue\", {\n        /**\n         * \\@name formValue\n         * @return {?}\n         */\n        get: function () {\n            var /** @type {?} */ form = this.inputForm.value;\n            return form ? form.value : '';\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * 3\n     * \\@name onDragStarted\n     * @param {?} event\n     * @param {?} tag\n     * @param {?} index\n     * @return {?}\n     */\n    TagInputComponent.prototype.onDragStarted = function (event, tag, index) {\n        event.stopPropagation();\n        var /** @type {?} */ item = ({ zone: this.dragZone, tag: tag, index: index });\n        this.dragProvider.setSender(this);\n        this.dragProvider.setDraggedItem(event, item);\n        this.dragProvider.setState({ dragging: true, index: index });\n    };\n    /**\n     * \\@name onDragOver\n     * @param {?} event\n     * @param {?=} index\n     * @return {?}\n     */\n    TagInputComponent.prototype.onDragOver = function (event, index) {\n        this.dragProvider.setState({ dropping: true });\n        this.dragProvider.setReceiver(this);\n        event.preventDefault();\n    };\n    /**\n     * \\@name onTagDropped\n     * @param {?} event\n     * @param {?} index\n     * @return {?}\n     */\n    TagInputComponent.prototype.onTagDropped = function (event, index) {\n        var /** @type {?} */ item = this.dragProvider.getDraggedItem(event);\n        if (item.zone !== this.dragZone) {\n            return;\n        }\n        this.dragProvider.onTagDropped(item.tag, item.index, index);\n        event.preventDefault();\n        event.stopPropagation();\n    };\n    /**\n     * \\@name isDropping\n     * @return {?}\n     */\n    TagInputComponent.prototype.isDropping = function () {\n        var /** @type {?} */ isReceiver = this.dragProvider.receiver === this;\n        var /** @type {?} */ isDropping = this.dragProvider.getState('dropping');\n        return Boolean(isReceiver && isDropping);\n    };\n    /**\n     * \\@name onTagBlurred\n     * @param {?} changedElement {TagModel}\n     * @param {?} index {number}\n     * @return {?}\n     */\n    TagInputComponent.prototype.onTagBlurred = function (changedElement, index) {\n        this.items[index] = changedElement;\n        this.blur();\n    };\n    /**\n     * \\@name trackBy\n     * @param {?} item\n     * @return {?}\n     */\n    TagInputComponent.prototype.trackBy = function (item) {\n        return item[this.identifyBy];\n    };\n    /**\n     *\n     * @param {?} tag\n     * @param {?=} fromAutocomplete\n     * @return {?}\n     */\n    TagInputComponent.prototype.isTagValid = function (tag, fromAutocomplete) {\n        var _this = this;\n        if (fromAutocomplete === void 0) {\n            fromAutocomplete = false;\n        }\n        var /** @type {?} */ selectedItem = this.dropdown ? this.dropdown.selectedItem : undefined;\n        if (selectedItem && !fromAutocomplete) {\n            return false;\n        }\n        var /** @type {?} */ dupe = this.findDupe(tag, fromAutocomplete);\n        // if so, give a visual cue and return false\n        if (!this.allowDupes && dupe && this.blinkIfDupe) {\n            var /** @type {?} */ model = this.tags.find(function (tag) {\n                return _this.getItemValue(tag.model) === _this.getItemValue(dupe);\n            });\n            if (model) {\n                model.blink();\n            }\n        }\n        var /** @type {?} */ isFromAutocomplete = fromAutocomplete && this.onlyFromAutocomplete;\n        var /** @type {?} */ assertions = [\n            // 1. there must be no dupe OR dupes are allowed\n            !dupe || this.allowDupes === true,\n            // 2. check max items has not been reached\n            this.maxItemsReached === false,\n            // 3. check item comes from autocomplete or onlyFromAutocomplete is false\n            ((isFromAutocomplete) || this.onlyFromAutocomplete === false)\n        ];\n        return assertions.filter(function (item) { return item; }).length === assertions.length;\n    };\n    /**\n     * \\@name moveToTag\n     * @param {?} item\n     * @param {?} direction\n     * @return {?}\n     */\n    TagInputComponent.prototype.moveToTag = function (item, direction) {\n        var /** @type {?} */ isLast = this.tags.last.model === item;\n        var /** @type {?} */ isFirst = this.tags.first.model === item;\n        var /** @type {?} */ stopSwitch = (direction === NEXT && isLast) ||\n            (direction === PREV && isFirst);\n        if (stopSwitch) {\n            this.focus(true);\n            return;\n        }\n        var /** @type {?} */ offset = direction === NEXT ? 1 : -1;\n        var /** @type {?} */ index = this.getTagIndex(item) + offset;\n        var /** @type {?} */ tag = this.getTagAtIndex(index);\n        return tag.select.call(tag);\n    };\n    /**\n     * \\@name getTagIndex\n     * @param {?} item\n     * @return {?}\n     */\n    TagInputComponent.prototype.getTagIndex = function (item) {\n        var /** @type {?} */ tags = this.tags.toArray();\n        return tags.findIndex(function (tag) { return tag.model === item; });\n    };\n    /**\n     * \\@name getTagAtIndex\n     * @param {?} index\n     * @return {?}\n     */\n    TagInputComponent.prototype.getTagAtIndex = function (index) {\n        var /** @type {?} */ tags = this.tags.toArray();\n        return tags[index];\n    };\n    /**\n     * \\@name removeItem\n     * @desc removes an item from the array of the model\n     * @param {?} tag {TagModel}\n     * @param {?} index {number}\n     * @return {?}\n     */\n    TagInputComponent.prototype.removeItem = function (tag, index) {\n        this.items = this.getItemsWithout(index);\n        // if the removed tag was selected, set it as undefined\n        if (this.selectedTag === tag) {\n            this.selectItem(undefined, false);\n        }\n        // focus input\n        this.focus(true, false);\n        // emit remove event\n        this.onRemove.emit(tag);\n    };\n    /**\n     * \\@name addItem\n     * @desc adds the current text model to the items array\n     * @param {?=} fromAutocomplete\n     * @param {?=} item\n     * @param {?=} index\n     * @return {?}\n     */\n    TagInputComponent.prototype.addItem = function (fromAutocomplete, item, index) {\n        var _this = this;\n        if (fromAutocomplete === void 0) {\n            fromAutocomplete = false;\n        }\n        var /** @type {?} */ model = this.getItemDisplay(item);\n        /**\n         * \\@name reset\n         */\n        var reset = function () {\n            // reset control and focus input\n            _this.setInputValue('');\n            // focus input\n            _this.focus(true, false);\n        };\n        /**\n         * \\@name validationFilter\n         * @param tag\n         */\n        var validationFilter = function (tag) {\n            var isValid = _this.isTagValid(tag, fromAutocomplete) && _this.inputForm.form.valid;\n            if (!isValid) {\n                _this.onValidationError.emit(tag);\n            }\n            return isValid;\n        };\n        /**\n         * \\@name subscribeFn\n         * @param tag\n         */\n        var subscribeFn = function (tag) {\n            _this.appendTag(tag, index);\n            // emit event\n            _this.onAdd.emit(tag);\n            if (!_this.dropdown) {\n                return;\n            }\n            _this.dropdown.hide();\n            _this.dropdown.showDropdownIfEmpty ? _this.dropdown.show() : undefined;\n        };\n        Observable$1\n            .of(model)\n            .first()\n            .filter(function () { return model.trim() !== ''; })\n            .map(function () { return item; })\n            .map(this.createTag)\n            .filter(validationFilter)\n            .subscribe(subscribeFn, undefined, reset);\n    };\n    /**\n     * \\@name setupSeparatorKeysListener\n     * @return {?}\n     */\n    TagInputComponent.prototype.setupSeparatorKeysListener = function () {\n        var _this = this;\n        var /** @type {?} */ useSeparatorKeys = this.separatorKeyCodes.length > 0 || this.separatorKeys.length > 0;\n        var /** @type {?} */ listener = function ($event) {\n            var /** @type {?} */ hasKeyCode = _this.separatorKeyCodes.indexOf($event.keyCode) >= 0;\n            var /** @type {?} */ hasKey = _this.separatorKeys.indexOf($event.key) >= 0;\n            if (hasKeyCode || hasKey) {\n                $event.preventDefault();\n                _this.onAddingRequested(false, _this.formValue);\n            }\n        };\n        listen.call(this, KEYDOWN, listener, useSeparatorKeys);\n    };\n    /**\n     * \\@name setUpKeypressListeners\n     * @return {?}\n     */\n    TagInputComponent.prototype.setUpKeypressListeners = function () {\n        var _this = this;\n        var /** @type {?} */ listener = function ($event) {\n            var /** @type {?} */ isCorrectKey = $event.keyCode === 37 || $event.keyCode === 8;\n            if (isCorrectKey &&\n                !_this.formValue &&\n                _this.items.length) {\n                _this.tags.last.select.call(_this.tags.last);\n            }\n        };\n        // setting up the keypress listeners\n        listen.call(this, KEYDOWN, listener);\n    };\n    /**\n     * \\@name setUpKeydownListeners\n     * @return {?}\n     */\n    TagInputComponent.prototype.setUpInputKeydownListeners = function () {\n        var _this = this;\n        this.inputForm.onKeydown.subscribe(function (event) {\n            _this.fireEvents('keydown', event);\n            if (event.key === 'Backspace' && _this.formValue === '') {\n                event.preventDefault();\n            }\n        });\n    };\n    /**\n     * \\@name setUpOnPasteListener\n     * @return {?}\n     */\n    TagInputComponent.prototype.setUpOnPasteListener = function () {\n        var /** @type {?} */ input = this.inputForm.input.nativeElement;\n        // attach listener to input\n        this.renderer.listen(input, 'paste', this.onPasteCallback);\n    };\n    /**\n     * \\@name setUpTextChangeSubscriber\n     * @return {?}\n     */\n    TagInputComponent.prototype.setUpTextChangeSubscriber = function () {\n        var _this = this;\n        this.inputForm.form\n            .valueChanges\n            .debounceTime(this.onTextChangeDebounce)\n            .map(function () { return _this.formValue; })\n            .subscribe(function (value) { return _this.onTextChange.emit(value); });\n    };\n    /**\n     * \\@name setUpOnBlurSubscriber\n     * @return {?}\n     */\n    TagInputComponent.prototype.setUpOnBlurSubscriber = function () {\n        var _this = this;\n        var /** @type {?} */ filterFn = function () {\n            return !(_this.dropdown && _this.dropdown.isVisible) && !!_this.formValue;\n        };\n        this.inputForm\n            .onBlur\n            .filter(filterFn)\n            .subscribe(function () {\n            if (_this.addOnBlur) {\n                _this.onAddingRequested(false, _this.formValue);\n            }\n            _this.setInputValue('');\n        });\n    };\n    /**\n     * \\@name findDupe\n     * @param {?} tag\n     * @param {?} isFromAutocomplete\n     * @return {?}\n     */\n    TagInputComponent.prototype.findDupe = function (tag, isFromAutocomplete) {\n        var _this = this;\n        var /** @type {?} */ identifyBy = isFromAutocomplete ? this.dropdown.identifyBy : this.identifyBy;\n        var /** @type {?} */ id = tag[identifyBy];\n        return this.items.find(function (item) { return _this.getItemValue(item) === id; });\n    };\n    /**\n     * \\@name setAnimationMetadata\n     * @return {?}\n     */\n    TagInputComponent.prototype.setAnimationMetadata = function () {\n        this.animationMetadata = {\n            value: 'in',\n            params: Object.assign({}, this.animationDuration)\n        };\n    };\n    return TagInputComponent;\n}(TagInputAccessor));\nvar DeleteIconComponent = /*@__PURE__*/ (function () {\n    function DeleteIconComponent() {\n    }\n    return DeleteIconComponent;\n}());\nvar optionsProvider = new OptionsProvider();\nvar TagInputModule = /*@__PURE__*/ (function () {\n    function TagInputModule() {\n    }\n    /**\n     * \\@name withDefaults\n     * @param {?} options {Options}\n     * @return {?}\n     */\n    TagInputModule.withDefaults = function (options) {\n        optionsProvider.setOptions(options);\n    };\n    return TagInputModule;\n}());\n/**\n * Generated bundle index. Do not edit.\n */\nexport { TagInputModule, TagInputDropdown, DeleteIconComponent, TagInputForm, TagRipple, TagComponent, TagInputComponent, TagInputDropdown as d, DeleteIconComponent as i, TagInputForm as e, animations$1 as c, TagInputComponent as a, TagRipple as g, TagComponent as f, TagInputAccessor as b, HighlightPipe as j, DragProvider as h };\n//# sourceMappingURL=ngx-chips.es5.js.map\n",null]}